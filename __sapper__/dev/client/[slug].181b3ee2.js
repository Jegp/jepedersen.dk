import { S as SvelteComponentDev, i as init, d as dispatch_dev, s as safe_not_equal, e as element, a as space, c as claim_element, b as children, f as claim_space, h as detach_dev, j as attr_dev, k as add_location, l as insert_dev, m as append_dev, t as text, g as claim_text, n as set_data_dev, q as query_selector_all, H as HtmlTag, o as noop } from './client.a08fa515.js';

/* src/routes/[slug].svelte generated by Svelte v3.18.1 */

const file = "src/routes/[slug].svelte";

// (6:0) {#if post.metadata.image}
function create_if_block(ctx) {
	let figure;
	let img;
	let img_src_value;
	let t;
	let if_block = /*post*/ ctx[0].metadata.caption && create_if_block_1(ctx);

	const block = {
		c: function create() {
			figure = element("figure");
			img = element("img");
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			figure = claim_element(nodes, "FIGURE", { class: true });
			var figure_nodes = children(figure);
			img = claim_element(figure_nodes, "IMG", { src: true, alt: true, class: true });
			t = claim_space(figure_nodes);
			if (if_block) if_block.l(figure_nodes);
			figure_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = /*post*/ ctx[0].metadata.image)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			attr_dev(img, "class", "svelte-gxuntl");
			add_location(img, file, 7, 1, 105);
			attr_dev(figure, "class", "svelte-gxuntl");
			add_location(figure, file, 6, 0, 95);
		},
		m: function mount(target, anchor) {
			insert_dev(target, figure, anchor);
			append_dev(figure, img);
			append_dev(figure, t);
			if (if_block) if_block.m(figure, null);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*post*/ 1 && img.src !== (img_src_value = /*post*/ ctx[0].metadata.image)) {
				attr_dev(img, "src", img_src_value);
			}

			if (/*post*/ ctx[0].metadata.caption) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(figure, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(figure);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(6:0) {#if post.metadata.image}",
		ctx
	});

	return block;
}

// (9:1) {#if post.metadata.caption}
function create_if_block_1(ctx) {
	let figcaption;
	let t;
	let if_block0 = /*post*/ ctx[0].metadata.captionlabel && create_if_block_3(ctx);

	function select_block_type(ctx, dirty) {
		if (/*post*/ ctx[0].metadata.captionlink) return create_if_block_2;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block1 = current_block_type(ctx);

	const block = {
		c: function create() {
			figcaption = element("figcaption");
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			figcaption = claim_element(nodes, "FIGCAPTION", { class: true });
			var figcaption_nodes = children(figcaption);
			if (if_block0) if_block0.l(figcaption_nodes);
			t = claim_space(figcaption_nodes);
			if_block1.l(figcaption_nodes);
			figcaption_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(figcaption, "class", "svelte-gxuntl");
			add_location(figcaption, file, 9, 2, 179);
		},
		m: function mount(target, anchor) {
			insert_dev(target, figcaption, anchor);
			if (if_block0) if_block0.m(figcaption, null);
			append_dev(figcaption, t);
			if_block1.m(figcaption, null);
		},
		p: function update(ctx, dirty) {
			if (/*post*/ ctx[0].metadata.captionlabel) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(figcaption, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(figcaption, null);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(figcaption);
			if (if_block0) if_block0.d();
			if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(9:1) {#if post.metadata.caption}",
		ctx
	});

	return block;
}

// (11:3) {#if post.metadata.captionlabel}
function create_if_block_3(ctx) {
	let t_value = /*post*/ ctx[0].metadata.captionlabel + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*post*/ 1 && t_value !== (t_value = /*post*/ ctx[0].metadata.captionlabel + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(11:3) {#if post.metadata.captionlabel}",
		ctx
	});

	return block;
}

// (18:3) {:else}
function create_else_block(ctx) {
	let t_value = /*post*/ ctx[0].metadata.caption + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*post*/ 1 && t_value !== (t_value = /*post*/ ctx[0].metadata.caption + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(18:3) {:else}",
		ctx
	});

	return block;
}

// (14:3) {#if post.metadata.captionlink}
function create_if_block_2(ctx) {
	let a;
	let t_value = /*post*/ ctx[0].metadata.caption + "";
	let t;
	let a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, t_value);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", a_href_value = /*post*/ ctx[0].metadata.captionlink);
			add_location(a, file, 14, 4, 309);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*post*/ 1 && t_value !== (t_value = /*post*/ ctx[0].metadata.caption + "")) set_data_dev(t, t_value);

			if (dirty & /*post*/ 1 && a_href_value !== (a_href_value = /*post*/ ctx[0].metadata.captionlink)) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(14:3) {#if post.metadata.captionlink}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let title_value;
	let t0;
	let t1;
	let section;
	let h1;
	let t2_value = /*post*/ ctx[0].metadata.title + "";
	let t2;
	let t3;
	let span;
	let t4_value = /*post*/ ctx[0].metadata.pubdate + "";
	let t4;
	let t5;
	let html_tag;
	let raw_value = /*post*/ ctx[0].html + "";
	document.title = title_value = /*post*/ ctx[0].metadata.title;
	let if_block = /*post*/ ctx[0].metadata.image && create_if_block(ctx);

	const block = {
		c: function create() {
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			section = element("section");
			h1 = element("h1");
			t2 = text(t2_value);
			t3 = space();
			span = element("span");
			t4 = text(t4_value);
			t5 = space();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1f4jeuj\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			t1 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			h1 = claim_element(section_nodes, "H1", {});
			var h1_nodes = children(h1);
			t2 = claim_text(h1_nodes, t2_value);
			h1_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			span = claim_element(section_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t4 = claim_text(span_nodes, t4_value);
			span_nodes.forEach(detach_dev);
			t5 = claim_space(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file, 27, 1, 502);
			attr_dev(span, "class", "date");
			add_location(span, file, 28, 1, 534);
			html_tag = new HtmlTag(raw_value, null);
			attr_dev(section, "class", "content svelte-gxuntl");
			add_location(section, file, 26, 0, 475);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, h1);
			append_dev(h1, t2);
			append_dev(section, t3);
			append_dev(section, span);
			append_dev(span, t4);
			append_dev(section, t5);
			html_tag.m(section);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*post*/ 1 && title_value !== (title_value = /*post*/ ctx[0].metadata.title)) {
				document.title = title_value;
			}

			if (/*post*/ ctx[0].metadata.image) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*post*/ 1 && t2_value !== (t2_value = /*post*/ ctx[0].metadata.title + "")) set_data_dev(t2, t2_value);
			if (dirty & /*post*/ 1 && t4_value !== (t4_value = /*post*/ ctx[0].metadata.pubdate + "")) set_data_dev(t4, t4_value);
			if (dirty & /*post*/ 1 && raw_value !== (raw_value = /*post*/ ctx[0].html + "")) html_tag.p(raw_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(section);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload({ params, query }) {
	// the `slug` parameter is available because
	// this file is called [slug].html
	const res = await this.fetch(`${params.slug}.json`);

	const data = await res.json();

	if (res.status === 200) {
		return { post: data };
	} else {
		this.error(res.status, data.message);
	}
}



function instance($$self, $$props, $$invalidate) {
	let { post } = $$props;
	const writable_props = ["post"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<U5Bslugu5D> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("post" in $$props) $$invalidate(0, post = $$props.post);
	};

	$$self.$capture_state = () => {
		return { post };
	};

	$$self.$inject_state = $$props => {
		if ("post" in $$props) $$invalidate(0, post = $$props.post);
	};

	return [post];
}

class U5Bslugu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { post: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bslugu5D",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*post*/ ctx[0] === undefined && !("post" in props)) {
			console.warn("<U5Bslugu5D> was created without expected prop 'post'");
		}
	}

	get post() {
		throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set post(value) {
		throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default U5Bslugu5D;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW3NsdWddLjE4MWIzZWUyLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcm91dGVzL1tzbHVnXS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHN2ZWx0ZTpoZWFkPlxuXHQ8dGl0bGU+e3Bvc3QubWV0YWRhdGEudGl0bGV9PC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cblxueyNpZiBwb3N0Lm1ldGFkYXRhLmltYWdlfVxuPGZpZ3VyZT5cblx0PGltZyBzcmM9XCJ7cG9zdC5tZXRhZGF0YS5pbWFnZX1cIiBhbHQ9XCJcIiAvPlxuXHR7I2lmIHBvc3QubWV0YWRhdGEuY2FwdGlvbn1cblx0XHQ8ZmlnY2FwdGlvbj5cblx0XHRcdHsjaWYgcG9zdC5tZXRhZGF0YS5jYXB0aW9ubGFiZWx9XG5cdFx0XHRcdHtwb3N0Lm1ldGFkYXRhLmNhcHRpb25sYWJlbH1cblx0XHRcdHsvaWZ9XG5cdFx0XHR7I2lmIHBvc3QubWV0YWRhdGEuY2FwdGlvbmxpbmt9XG5cdFx0XHRcdDxhIGhyZWY9XCJ7cG9zdC5tZXRhZGF0YS5jYXB0aW9ubGlua31cIj5cblx0XHRcdFx0XHR7cG9zdC5tZXRhZGF0YS5jYXB0aW9ufVxuXHRcdFx0XHQ8L2E+XG5cdFx0XHR7OmVsc2V9XG5cdFx0XHRcdHtwb3N0Lm1ldGFkYXRhLmNhcHRpb259XG5cdFx0XHR7L2lmfVxuXHRcdDwvZmlnY2FwdGlvbj5cblx0ey9pZn1cbjwvZmlndXJlPlxuey9pZn1cblxuXG48c2VjdGlvbiBjbGFzcz0nY29udGVudCc+XG5cdDxoMT57cG9zdC5tZXRhZGF0YS50aXRsZX08L2gxPlxuXHQ8c3BhbiBjbGFzcz1cImRhdGVcIj57cG9zdC5tZXRhZGF0YS5wdWJkYXRlfTwvc3Bhbj5cblx0e0BodG1sIHBvc3QuaHRtbH1cbjwvc2VjdGlvbj5cblxuPHN0eWxlPlxuXHRmaWd1cmUge1xuXHRcdG1hcmdpbjogMCBhdXRvO1xuXHR9XG5cblx0ZmlndXJlIGltZyB7XG5cdFx0aGVpZ2h0OiBhdXRvO1xuXHRcdG1heC1oZWlnaHQ6IDM4NHB4O1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0fVxuXG5cdGZpZ2NhcHRpb24ge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdGZvbnQtc2l6ZTogLjg3NWVtO1xuXHRcdGZvbnQtc3R5bGU6IGl0YWxpYztcblx0XHRwYWRkaW5nOiAwIDFlbTtcblx0fVxuXG5cdC5jb250ZW50IHtcblx0XHRtYXgtd2lkdGg6IDQwZW07XG5cdFx0cGFkZGluZzogMWVtIDJlbSAyZW07XG5cdFx0bWFyZ2luOiAwIGF1dG87XG5cdFx0dGV4dC1hbGlnbjogbGVmdDtcblx0fVxuXG5cdC8qXG5cdFx0QnkgZGVmYXVsdCwgQ1NTIGlzIGxvY2FsbHkgc2NvcGVkIHRvIHRoZSBjb21wb25lbnQsXG5cdFx0YW5kIGFueSB1bnVzZWQgc3R5bGVzIGFyZSBkZWFkLWNvZGUtZWxpbWluYXRlZC5cblx0XHRJbiB0aGlzIHBhZ2UsIFN2ZWx0ZSBjYW4ndCBrbm93IHdoaWNoIGVsZW1lbnRzIGFyZVxuXHRcdGdvaW5nIHRvIGFwcGVhciBpbnNpZGUgdGhlIHt7e3Bvc3QuaHRtbH19fSBibG9jayxcblx0XHRzbyB3ZSBoYXZlIHRvIHVzZSB0aGUgOmdsb2JhbCguLi4pIG1vZGlmaWVyIHRvIHRhcmdldFxuXHRcdGFsbCBlbGVtZW50cyBpbnNpZGUgLmNvbnRlbnRcblx0Ki9cblxuXHQuY29udGVudCA6Z2xvYmFsKGgyKSB7XG5cdFx0Zm9udC1zaXplOiAxLjRlbTtcblx0XHRmb250LXdlaWdodDogNTAwO1xuXHR9XG5cblx0LmNvbnRlbnQgOmdsb2JhbChwcmUpIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjlmOWY5O1xuXHRcdGJveC1zaGFkb3c6IGluc2V0IDFweCAxcHggNXB4IHJnYmEoMCwwLDAsMC4wNSk7XG5cdFx0cGFkZGluZzogMC41ZW07XG5cdFx0Ym9yZGVyLXJhZGl1czogMnB4O1xuXHRcdG92ZXJmbG93LXg6IGF1dG87XG5cdH1cblxuXHQuY29udGVudCA6Z2xvYmFsKHByZSkgOmdsb2JhbChjb2RlKSB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0cGFkZGluZzogMDtcblx0fVxuXG5cdC5jb250ZW50IDpnbG9iYWwodWwpIHtcblx0XHRsaW5lLWhlaWdodDogMS41O1xuXHR9XG5cblx0LmNvbnRlbnQgOmdsb2JhbChsaSkge1xuXHRcdG1hcmdpbjogMCAwIDAuNWVtIDA7XG5cdH1cbjwvc3R5bGU+XG5cbjxzY3JpcHQ+XG5cdGV4cG9ydCBsZXQgcG9zdDtcbjwvc2NyaXB0PlxuXG48c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cblxuXHRleHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlbG9hZCh7IHBhcmFtcywgcXVlcnkgfSkge1xuXHRcdFx0Ly8gdGhlIGBzbHVnYCBwYXJhbWV0ZXIgaXMgYXZhaWxhYmxlIGJlY2F1c2Vcblx0XHRcdC8vIHRoaXMgZmlsZSBpcyBjYWxsZWQgW3NsdWddLmh0bWxcblx0XHRcdGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZmV0Y2goYCR7cGFyYW1zLnNsdWd9Lmpzb25gKTtcblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuXG5cdFx0XHRpZiAocmVzLnN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRcdHJldHVybiB7IHBvc3Q6IGRhdGEgfTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZXJyb3IocmVzLnN0YXR1cywgZGF0YS5tZXNzYWdlKTtcblx0XHRcdH1cblx0XHR9O1xuXG48L3NjcmlwdD4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3lCQVFNLEdBQUksSUFBQyxRQUFRLENBQUMsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkNBRGYsR0FBSSxJQUFDLFFBQVEsQ0FBQyxLQUFLOzs7Ozs7Ozs7Ozs7OzttRUFBbkIsR0FBSSxJQUFDLFFBQVEsQ0FBQyxLQUFLOzs7O2dCQUN6QixHQUFJLElBQUMsUUFBUSxDQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBRW5CLEdBQUksSUFBQyxRQUFRLENBQUMsWUFBWTs7O2VBRzFCLEdBQUksSUFBQyxRQUFRLENBQUMsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBSHpCLEdBQUksSUFBQyxRQUFRLENBQUMsWUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQUM3QixHQUFJLElBQUMsUUFBUSxDQUFDLFlBQVk7Ozs7Ozs7Ozs7Ozs7OzZEQUExQixHQUFJLElBQUMsUUFBUSxDQUFDLFlBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQU8xQixHQUFJLElBQUMsUUFBUSxDQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7OzZEQUFyQixHQUFJLElBQUMsUUFBUSxDQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFIcEIsR0FBSSxJQUFDLFFBQVEsQ0FBQyxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7K0NBRGIsR0FBSSxJQUFDLFFBQVEsQ0FBQyxXQUFXOzs7Ozs7Ozs2REFDakMsR0FBSSxJQUFDLFFBQVEsQ0FBQyxPQUFPOzt1RUFEYixHQUFJLElBQUMsUUFBUSxDQUFDLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQWFqQyxHQUFJLElBQUMsUUFBUSxDQUFDLEtBQUs7Ozs7eUJBQ0osR0FBSSxJQUFDLFFBQVEsQ0FBQyxPQUFPOzs7OzBCQUNsQyxHQUFJLElBQUMsSUFBSTt5Q0E1QlIsR0FBSSxJQUFDLFFBQVEsQ0FBQyxLQUFLO3lCQUl2QixHQUFJLElBQUMsUUFBUSxDQUFDLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FFQUpmLEdBQUksSUFBQyxRQUFRLENBQUMsS0FBSzs7OztnQkFJdkIsR0FBSSxJQUFDLFFBQVEsQ0FBQyxLQUFLOzs7Ozs7Ozs7Ozs7OytEQXNCbEIsR0FBSSxJQUFDLFFBQVEsQ0FBQyxLQUFLOytEQUNKLEdBQUksSUFBQyxRQUFRLENBQUMsT0FBTztpRUFDbEMsR0FBSSxJQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBM0JNLE9BQU8sR0FBRyxNQUFNLEVBQUUsS0FBSzs7O09BR3JDLEdBQUcsU0FBUyxJQUFJLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxJQUFJOztPQUNyQyxJQUFJLFNBQVMsR0FBRyxDQUFDLElBQUk7O0tBRXZCLEdBQUcsQ0FBQyxNQUFNLEtBQUssR0FBRztXQUNaLElBQUksRUFBRSxJQUFJOztFQUVuQixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU87Ozs7Ozs7T0FWM0IsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
